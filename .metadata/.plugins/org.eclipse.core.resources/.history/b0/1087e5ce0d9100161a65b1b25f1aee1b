<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>飞机大战</title>
	</head>

	<body>
		<div id="stage" style="margin: 0 auto; width: 480px; height: 650px; text-align: center; vertical-align: middle" >
			<canvas id="canvas" style="border:0px solid red;" width="480" height="650">
				不支持画板对象
			</canvas>
		</div>
		<script>
			var canvas = document.getElementById('canvas');
			var ctx = canvas.getContext('2d');

			var background = new Image();
			background.src = "images/background.png";

			var sky = new Sky();

			var e1 = [];
			e1[0] = new Image();
			e1[0].src = "images/enemy1.png";
			e1[1] = new Image();
			e1[1].src = "images/enemy1_down1.png";
			e1[2] = new Image();
			e1[2].src = "images/enemy1_down2.png";
			e1[3] = new Image();
			e1[3].src = "images/enemy1_down3.png";
			e1[4] = new Image();
			e1[4].src = "images/enemy1_down4.png";

			var e2 = [];
			e2[0] = new Image();
			e2[0].src = "images/enemy2.png";
			e2[1] = new Image();
			e2[1].src = "images/enemy2_down1.png";
			e2[2] = new Image();
			e2[2].src = "images/enemy2_down2.png";
			e2[3] = new Image();
			e2[3].src = "images/enemy2_down3.png";
			e2[4] = new Image();
			e2[4].src = "images/enemy2_down4.png";

			var e3 = [];
			e3[0] = new Image();
			e3[0].src = "images/enemy3_n1.png";
			e3[1] = new Image();
			e3[1].src = "images/enemy3_n2.png";
			e3[2] = new Image();
			e3[2].src = "images/enemy3_down1.png";
			e3[3] = new Image();
			e3[3].src = "images/enemy3_down2.png";
			e3[4] = new Image();
			e3[4].src = "images/enemy3_down3.png";
			e3[5] = new Image();
			e3[5].src = "images/enemy3_down4.png";
			e3[6] = new Image();
			e3[6].src = "images/enemy3_down5.png";
			e3[7] = new Image();
			e3[7].src = "images/enemy3_down6.png";

			var h = [];
			h[0] = new Image();
			h[0].src = "images/hero1.png";
			h[1] = new Image();
			h[1].src = "images/hero2.png";
			h[2] = new Image();
			h[2].src = "images/hero_blowup_n1.png";
			h[3] = new Image();
			h[3].src = "images/hero_blowup_n2.png";
			h[4] = new Image();
			h[4].src = "images/hero_blowup_n3.png";
			h[5] = new Image();
			h[5].src = "images/hero_blowup_n4.png";
			//添加无敌状态图片
			h[6] = new Image();
			h[6].src = "images/hero1_protect1.png";
			h[7] = new Image();
			h[7].src = "images/hero1_protect2.png";
			//添加无敌销毁状态图片
			h[8] = new Image();
			h[8].src = "images/hero_protect_disapper_n1.png";
			h[9] = new Image();
			h[9].src = "images/hero_protect_disapper_n2.png";
			h[10] = new Image();
			h[10].src = "images/hero_protect_disapper_n3.png";

			var b = [];
			b[0] = new Image();
			b[0].src = "images/bullet1.png";
			b[1] = new Image();
			b[1].src = "images/bullet2.png";

			//创建图片对象，存储ufo图片资源
			var u = [];
			u[0] = new Image();
			u[0].src = "images/ufo1.png";
<<<<<<< HEAD
=======

			//创建图片数组，存储shield图片资源
			var s = [];
			s[0] = new Image();
			s[0].src = "images/shield.png";
>>>>>>> 74b32fe... start  modify  super loss

			//创建图片，存储heart图片资源
			var heart = new Image();
			heart.src = "images/heart.png";

			//创建图片，存储blood图片资源
			var blood = [];
			for (var i = 0; i < 20; i++) {
				blood[i] = new Image();
				blood[i].src = "images/blood" + (i + 1) + ".png";
			}

			var copyright = new Image();
			copyright.src = "images/shoot_copyright.png";

			var pause = new Image();
			pause.src = "images/game_pause_nor.png";

			var enemies = [];
			var hero = new Hero(0, 0, 99, 124, 1, h, 2,4,2,3);
			var bullets = [];
			var score = 0;
			var heroes = 30;
			//新添数组，用于存储ufo对象
			var ufo = [];
<<<<<<< HEAD
=======

			//新添数组，用于存储shield对象
			var shields = [];
>>>>>>> 74b32fe... start  modify  super loss

			//新添数组，用于存储life对象
			var life = [];

			//新添数组，用于存储hp对象
			var hp = [];

			var START = 1;

			var RUNNING = 2;

			var PAUSE = 3;

			var GAME_OVER = 4;

			var state = START;

			canvas.onclick = function() {

				if (state == START) {
					state = RUNNING;
				}
			}

			canvas.onmouseout = function() {

				if (state == RUNNING) {
					state = PAUSE;
				}
			}

			canvas.onmouseover = function() {

				if (state == PAUSE) {
					state = RUNNING;
				}
			}
			setInterval(function() {

				controlState(ctx);
			}, 10);

			function isActionTime(lastTime, interval) {
				if (lastTime == 0) {
					return true;
				}
				var currentTime = new Date().getTime();
				return currentTime - lastTime >= interval;
			}

			var lastTime = 0;
			var interval = 400;

			function controlState(ctx) {

				switch(state) {

					case START:

						sky.paint(ctx);

						sky.step();

						var x = 20;
						var y = 130;

						ctx.drawImage(copyright, x, y);

						break;

					case RUNNING:

						paintComponent(ctx);

						componentStep();

						componentEnter();

						hero.shoot();

						checkHit();

						deleteComponent();

						break;

					case PAUSE:

						paintComponent(ctx);

						sky.step();

						ctx.drawImage(pause, 0, 0);

						break;

					case GAME_OVER:

						paintComponent(ctx)

						sky.step();

						var x = 480 / 2 - 245 / 2;
						var y = 852 * (1 - 0.6);

						ctx.font = "40px 微软雅黑";

						ctx.fillText("GAME OVER", x, y);

						break;
				}
			}

			function componentEnter() {
				if (! isActionTime(lastTime, interval)) {
					return;
				}
				lastTime = new Date().getTime();
				var n = parseInt(Math.random() * 10);
				switch(n) {
					case 0:
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7:
						enemies[enemies.length] = new Enemy(0, -51, 57, 51, 1, 1, 1, e1, 1);
						break;
					case 8:
						enemies[enemies.length] = new Enemy(0, -95, 69, 95, 2, 3, 5, e2, 1);
						break;
					case 9:
						if (enemies[0] == undefined || enemies[0].type != 3) {
							enemies.splice(0, 0, new Enemy(0, -258, 169, 258, 3, 20, 20, e3, 2));
						}
				}
				//新添创建ufo对象。参数(x, y, width, height, life, frames, baseFrameCount)
				var random = parseInt(Math.random() * 100);
				if (random == 1) {
					ufo[ufo.length] = new Ufo(0, 0, 58, 88, 1, u, 1);
				}
<<<<<<< HEAD
=======

				//添加shield对象。参数Shield(x, y, width, height, life, frames, baseFrameCount)
				if (random == 2) {
					shields[shields.length] = new Shield(0, 0, 59, 108, 1, s, 1);
				}

>>>>>>> 74b32fe... start  modify  super loss
				//新添，关闭多重火力的开关
				if (hero.power <= 0) {
					hero.multipleFire = false;
				}
			}

			//新添创建生命值对象。参数(x,y,img)
			for (var i = 0; i < heroes; i++) {
				life[i] = new Life(i * 25 + 400, 3, heart);
			}

			function componentStep() {
				sky.step();
				for (var i = 0; i < enemies.length; i++) {
					enemies[i].step();
				}
				for (var i = 0; i < bullets.length; i++) {
					bullets[i].step();
				}
				hero.step();
				//6.新添ufo飞行物移动
				for (var i = 0; i < ufo.length; i++) {
					if (ufo[i]) {
						ufo[i].step();
					}
				}

				//shield飞行物移动
				for (var i = 0; i < shields.length; i++) {
					if (shields[i]) {
						shields[i].step();
					}
				}
			}

			var paintLastTime = 0;
			var paintInterval = 40;
			function paintComponent(ctx) {
				if (! isActionTime(paintLastTime, paintInterval)) {
					return;
				}
				paintLastTime = new Date().getTime();
				sky.paint(ctx);
				for (var i = 0; i < enemies.length; i++) {
					enemies[i].paint(ctx);
				}
				for (var i = 0; i < bullets.length; i++) {
					bullets[i].paint(ctx);
				}
				hero.paint(ctx);

				//新添画ufo飞行物
				for (var i = 0; i < ufo.length; i++) {
					if (ufo[i]) {
						ufo[i].paint(ctx);
					}
				}

				//画shield飞行物
				for (var i = 0; i < shields.length; i++) {
					if (shields[i]) {
						shields[i].paint(ctx);
					}
				}

				ctx.font = "20px 微软雅黑";
				ctx.fillText("SCORE:" + score, 10, 20);
				//ctx.fillText("LIFE:" + heroes, 400, 20);
				//画生命值
				ctx.fillText("LIFE:", 350, 20);
				for (var i = 0; i < heroes; i++) {
					ctx.drawImage(life[i].img, life[i].x, life[i].y);
				}

				//新添画血条对象。参数(x,y,img)
				if (enemies[0].type == 3) {
					hp[0] = new Blood(enemies[0].x + 63, enemies[0].y + 250, blood[enemies[0].life]);
					hp[0].paint(ctx);
				}
			}

			function Sky() {
				this.img = background;
				this.width = 480;
				this.height = 852;
				this.x1 = 0;
				this.y1 = 0;
				this.x2 = 0;
				this.y2 = -this.height;
				this.interval = 400;
				this.lastTime = 0;
				this.paint = function(ctx) {
					ctx.drawImage(this.img, this.x1, this.y1);
					ctx.drawImage(this.img, this.x2, this.y2);
				}
				this.step = function() {
					if (! isActionTime(this.lastTime, this.interval)) {
						return;
					}
					this.lastTime = new Date().getTime();
					this.y1 = this.y1 + 1;
					this.y2 = this.y2 + 1;
					if (this.y1 > this.height) {
						this.y1 = -this.height;
					}
					if (this.y2 > this.height) {
						this.y2 = -this.height;
					}
				}
			}

			function getPointOnCanvas(x, y) {
				var bbox = canvas.getBoundingClientRect();
				return {
					x : x - bbox.left,
					y : y - bbox.top
				};
			}


			canvas.onmousemove = function(e) {
				if (state == RUNNING) {
					var mpoint = getPointOnCanvas(e.x, e.y);
					hero.x = mpoint.x - hero.width / 2;
					hero.y = mpoint.y - hero.height / 2;
				}

			}
			function FlyingObject(x, y, width, height, life, frames, baseFrameCount) {
				this.x = x;
				this.y = y;
				this.width = width;
				this.height = height;
				this.life = life;
				this.frames = frames;
				this.img = frames[0];
				this.frameIndex = 0;
				this.frameCount = baseFrameCount;
				this.interval = 10;
				this.lastTime = 0;
				this.down = false;
				this.canDelete = false;
				this.paint = function(ctx) {
					ctx.drawImage(this.img, this.x, this.y);
				}
				this.step = function() {
					if (!isActionTime(this.lastTime, this.interval)) {
						return;
					}
					this.lastTime = new Date().getTime();
					if (this.down) {
						if (this.frameIndex == this.frames.length) {
							this.canDelete = true;
						} else {
							this.img = this.frames[this.frameIndex];
							this.frameIndex++;
						}
					} else {
						this.move();
						this.img = this.frames[this.frameIndex % this.frameCount];
						this.frameIndex++;
					}

				}
				this.move = function() {
					this.y++;
				}
				this.hit = function(component) {
					var c = component;
					return c.x > this.x - c.width && c.x < this.x + this.width && c.y > this.y - c.height && c.y < this.y + this.height;
				}
				this.bang = function() {
					this.life--;
					if (this.life == 0) {
						this.down = true;
						if (this.score) {
							score = score + this.score;
						}
						this.frameIndex = this.frameCount;
					}
				}
				this.outOfBounds = function() {
					return this.y >= 852;
				}
			}

			function Enemy(x, y, width, height, type, life, score, frames, baseFrameCount) {
				FlyingObject.call(this, x, y, width, height, life, frames, baseFrameCount);
				this.x = Math.random() * (480 - this.width);
				this.y = -this.height;
				this.score = score;
				this.type = type;
			}

			//TODO 添加无敌状态
			function Hero(x, y, width, height, life, frames, baseFrameCount, DestroyHeroFrameCount, SuperHeroFrameCount,DestroySHFrameCount) {
				FlyingObject.call(this, x, y, width, height, life, frames, baseFrameCount);
				this.x = 480 / 2 - this.width / 2;
				this.y = 650 - this.height - 30;
				this.shootInterval = 100;
				this.shootLastTime = 0;
				//新添属性，代表多重火力是否开启
				this.multipleFire = false;
				//新添属性，代表开启多重火力的能量
				this.power = 0;
				this.shoot = function() {
					if (!isActionTime(this.shootLastTime, this.shootInterval)) {
						return;
					}
					this.shootLastTime = new Date().getTime();
					//原来的代码
					//bullets[bullets.length] = new Bullet(this.x + 45, this.y, 9, 21, 1, b, 2);
					//新添的多重火力
					if (this.multipleFire) {
						bullets[bullets.length] = new Bullet(this.x + 45, this.y + 1, 9, 21, 1, b, 1, 1);
						bullets[bullets.length] = new Bullet(this.x + 45, this.y + 1, 9, 21, 1, b, 1, 2);
						bullets[bullets.length] = new Bullet(this.x + 45, this.y + 1, 9, 21, 1, b, 1, 3);
						bullets[bullets.length] = new Bullet(this.x + 45, this.y + 1, 9, 21, 1, b, 1, 4);
						bullets[bullets.length] = new Bullet(this.x + 45, this.y + 1, 9, 21, 1, b, 1, 5);
						//新添，能量衰减
						this.power--;
					} else {
						bullets[bullets.length] = new Bullet(this.x + 45, this.y, 9, 21, 1, b, 1);
					}
					//无敌时间缩减
					this.superTime--;
				}
				this.move = function() {
				
				}
				
				//记录不同图片的帧数
				this.baseFrameCount = baseFrameCount;
				this.DestroyHeroFrameCount = DestroyHeroFrameCount;
				this.SuperHeroFrameCount = SuperHeroFrameCount;
				this.DestroySHFrameCount = DestroySHFrameCount;
				
				//记录无敌状态结束开始播放动画
				this.superStartOver = 0;
				//记录死亡状态开始播放动画
				this.dieStart = 0;
				
				//飞机无敌时间
				this.superTime = 0;
				//飞机状态对象
				this.STATE = {
					normal : "NORMAL",
					super : "SUPER",
					die : "DIE"
				};
				//当前状态
				this.currentState = this.STATE.normal;
				//下一个状态
				this.nextState = null;
				this.checkState = function() {
					//TODO
					//检测英雄机状态并根据当前所处状态设置currentState、nextState为null、superTime并设置背景图
					if(this.nextState != null){
						//飞机状态需要发生改变
						//进入无敌状态
						if(this.nextState == this.STATE.super){
							this.currentState = this.nextState;
							this.superTime += 1000;
							this.nextState = null;
							//TODO 切换图片
							//刚进入无敌状态
							if(this.superTime == 10){
							this.frameIndex = 0;
							}
							
						}
						//无敌状态结束
						if(this.currentState == this.STATE.super && this.nextState == this.STATE.normal){
							//切换图片
							//判断是否无敌状态刚结束
							if(this.superStartOver == 0){
								this.frameIndex = 0;
							}
							this.img = this.frames[this.frameIndex%this.DestroySHFrameCount + 8];
							this.frameIndex++;
							this.superStartOver++;
							//如果动画播放完了才让无敌状态消失还是开始播放动画就让无敌状态消失可以在这里通过if语句设置
							if(this.superStartOver == this.DestroySHFrameCount){
							this.currentState = this.nextState;
							this.superTime = 0;
							this.nextState = null;
							this.superStartOver = 0;
							}
						}
						//进入死亡状态
						if(this.nextState == this.STATE.die){
							//切换图片
							if(this.dieStart == 0){
								this.frameIndex = 0;
							}
							this.img = this.frames[this.frameIndex%this.DestroyHeroFrameCount + 2];
							this.frameIndex++;
							this.dieStart++;
							//需在动画播放完毕之后才设置以下属性
							if(this.dieStart == this.DestroyHeroFrameCount){
							this.currentState = this.nextState;
							this.canDelete = true;
							this.nextState = null;
							this.dieStart = 0;								
							}
						}
					}else{
						//说明飞机状态没有发生改变
						//切换图片
						
						//检查无敌时间是否已经到
						if(this.superTime <= 0){
							this.nextState = this.STATE.normal;
						}
						
						//飞机处于不同状态（正常、无敌、死亡）时设置其显示的图片
						if(this.currentState == this.STATE.normal){
							this.frameIndex++;
							this.img = this.frames[this.frameIndex%this.baseFrameCount + 0];
						}
						if(this.currentState == this.STATE.super){
							this.frameIndex++;
							var a = this.frameIndex%this.SuperHeroFrameCount;
							this.img = this.frames[a + 6];
						}
						
					}
					
					
					
				}
				//TODO
				// //重写父类方法的hit方法
				// this.hit = function(component) {
				// var c = component;
				// //根据当前所处状态及所碰撞的东西返回不同的值
				// return c.x > this.x - c.width && c.x < this.x + this.width && c.y > this.y - c.height && c.y < this.y + this.height;
				// }

				//英雄机重写父类的bang方法
				this.bang = function() {
					this.life--;
					if (this.life == 0) {
						//this.down = true;
						//将英雄机的状态修改为死亡,设置播放死亡动画在checkState方法里设置
						this.nextState = this.STATE.die;
						if (this.score) {
							score = score + this.score;
						}
						//this.frameIndex = this.frameCount;
					}
				}
				//重写父类方法的step方法
				this.step = function() {
					if (!isActionTime(this.lastTime, this.interval)) {
						return;
					}
					this.lastTime = new Date().getTime();
					//英雄机没死的话就移动
					if (this.currentState != this.STATE.die) {
						this.move();
					}
					this.checkState();
					
					// if (this.down) {
					// if (this.frameIndex == this.frames.length) {
					// this.canDelete = true;
					// } else {
					// this.img = this.frames[this.frameIndex];
					// this.frameIndex++;
					// }
					// } else {
					// this.move();
					// this.img = this.frames[this.frameIndex % this.frameCount];
					// this.frameIndex++;
					// }

					/*
					if (this.down) {
						//飞机死亡后播放坠毁动画
						// if (this.frameIndex == this.frames.length) {
						// this.canDelete = true;
						// } else {
						// this.img = this.frames[this.frameIndex];
						// this.frameIndex++;
						// }
						if (this.currentState != this.STATE.die) {

						}
						this.checkState();
					} else {
						this.move();
						// this.img = this.frames[this.frameIndex % this.frameCount];
						// this.frameIndex++;
						this.checkState();
					}
					*/

				}
			}

			function Bullet(x, y, width, height, life, frames, baseFrameCount, type) {
				FlyingObject.call(this, x, y, width, height, life, frames, baseFrameCount);
				this.move = function() {
					this.y -= 2;
					//新添子弹轨迹
					switch(type) {
						case 1 :
							this.x -= 1;
							break;
						case 2 :
							this.x -= 0.45;
							break;
						case 3 :
							break;
						case 4 :
							this.x += 0.45;
							break;
						case 5 :
							this.x += 1;
							break;
					}
				}
				this.outOfBounds = function() {
					return this.y < -this.height;
				}
			}

			/**
			 *新添奖励飞行物构造方法
			 */
			function Ufo(x, y, width, height, life, frames, baseFrameCount) {
				FlyingObject.call(this, x, y, width, height, life, frames, baseFrameCount);
				this.x = Math.random() * (480 - this.width);
				this.y = -this.height;
				//this.move = function(){}
			}
<<<<<<< HEAD
=======

			/**
			 *盾牌对象构造方法
			 */
			function Shield(x, y, width, height, life, frames, baseFrameCount) {
				FlyingObject.call(this, x, y, width, height, life, frames, baseFrameCount);
				this.x = Math.random() * (480 - this.width);
				this.y = -this.height;
			}
>>>>>>> 74b32fe... start  modify  super loss

			/**
			 *新添生命值爱心构造方法
			 */
			function Life(x, y, img) {
				this.x = x;
				this.y = y;
				this.img = img;
			}

			/**
			 *新添血条构造方法
			 */
			function Blood(x, y, img) {
				this.x = x;
				this.y = y;
				this.img = img;
				this.paint = function(ctx) {
					ctx.drawImage(this.img, this.x, this.y);
				}
			}

			//新添方法，为多重火力进行装弹（充能）
			function reload(number) {
				hero.power += number;
				if (hero.power > 0) {
					hero.multipleFire = true;
				}
			}

			function checkHit() {
				//新添检测ufo飞行物是否与英雄机相撞
				for (var i = 0; i < ufo.length; i++) {
					if (ufo[i].hit(hero)) {
						ufo[i].bang();
						//新添，开启多重火力
						reload(5);
					}
				}

				//检测shield飞行物是否与英雄级相撞
				for (var i = 0; i < shields.length; i++) {
					if (shields[i].hit(hero)) {
						shields[i].bang();
						//TODO 英雄机开启无敌模式
						//alert("英雄级撞到了盾牌");
						hero.nextState = hero.STATE.super;
					}
				}

				for (var i = 0; i < enemies.length; i++) {
					var enemy = enemies[i];
					if (enemy.canDelete || enemy.down) {
						continue;
					}
					for (var j = 0; j < bullets.length; j++) {
						var bullet = bullets[j];
						if (bullet.canDelete) {
							continue;
						}
						if (enemy.hit(bullet)) {
							if (!bullet.down) {
								enemy.bang();
							}

							bullet.bang();
						}
					}
					if (enemy.hit(hero)) {
						//敌机与英雄级发生碰撞后敌机肯定会死，但如果英雄机出于无敌状态则英雄级不会死
						enemy.bang();
						if (hero.currentState != hero.STATE.super) {
							hero.bang();
						}
					}
				}
			}

			function deleteComponent() {
				var ary = [];
				var idx = 0;
				for (var i = 0; i < enemies.length; i++) {
					if (!(enemies[i].canDelete || enemies[i].outOfBounds())) {
						ary[idx] = enemies[i];
						idx++;
					}
				}
				enemies = ary;

				ary = [];
				idx = 0;
				for (var i = 0; i < bullets.length; i++) {
					if (!(bullets[i].canDelete || bullets[i].outOfBounds())) {
						ary[idx] = bullets[i];
						idx++;
					}
				}
				bullets = ary;
				//新添，删除ufo飞行物
				ary = [];
				idx = 0;
				for (var i = 0; i < ufo.length; i++) {
					if (!(ufo[i].canDelete || ufo[i].outOfBounds())) {
						ary[idx] = ufo[i];
						idx++;
					}
				}
				ufo = ary;

				//删除shield飞行物
				ary = [];
				idx = 0;
				for (var i = 0; i < shields.length; i++) {
					if (!(shields[i].canDelete || shields[i].outOfBounds())) {
						ary[idx] = shields[i];
						idx++;
					}
				}
				shields = ary;

				if (hero.canDelete) {
					heroes--;
					if (heroes == 0) {
						state = GAME_OVER;
					} else {
						hero = new Hero(0, 0, 99, 124, 1, h, 2,4,2,3);
					}
				}
			}

		</script>
	</body>
</html>